<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Special Question for You...</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a nice, clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Using a custom font from Google Fonts */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure the canvas covers the image container perfectly */
        #scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grabbing;
        }
        /* Adding a custom cursor */
        .custom-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>'), auto;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen font-sans p-4 overflow-hidden">

    <div class="text-center w-full max-w-lg mx-auto">
        <!-- Main heading that changes at the end -->
        <h1 id="main-heading" class="text-3xl md:text-4xl font-bold mb-6 text-pink-300 transition-opacity duration-500">Scratch to reveal my love... ❤️</h1>
        
        <!-- Container for the scratch card. The image is set as a background. -->
        <div id="card-container" class="relative w-full aspect-video rounded-2xl shadow-2xl overflow-hidden bg-cover bg-center bg-no-repeat transition-all duration-500 custom-cursor">
            <!-- The canvas for scratching is inserted here by JavaScript -->
        </div>
        
        <!-- Sub-heading that provides instructions and the final message -->
        <h2 id="sub-heading" class="text-2xl md:text-3xl font-semibold mt-8 h-10 opacity-0 transition-opacity duration-500 ease-in-out"></h2>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENT SELECTION ---
            const cardContainer = document.getElementById('card-container');
            const mainHeading = document.getElementById('main-heading');
            const subHeading = document.getElementById('sub-heading');

            // --- IMAGE ASSETS ---
            // An array of modern actress images
            const actressImages = [
                'https://images.filmibeat.com/webp/wallpapers/desktop/2023/01/kriti-sanon_54.jpg', // Kriti Sanon
                'https://images.filmibeat.com/webp/wallpapers/desktop/2021/02/sanya-malhotra_5.jpg', // Sanya Malhotra
                'https://images.filmibeat.com/webp/wallpapers/desktop/2023/03/latest-photos-of-sharvari-wagh_23.jpg', // Sharvari
                'https://images.filmibeat.com/webp/ph-big/2023/10/wamiqa-gabbi_169761852410.jpg', // Wamiqa Gabbi
            ];
            // The final image
            
            const finalImage = 'https://i.ibb.co/3m3k2jnd/you.png'; // A finger pointing forward

            // --- STATE MANAGEMENT ---
            let imagesToShow = [];
            let currentImageIndex = 0;
            let isDrawing = false;
            let canvas, ctx;
            let revealInProgress = false; // Prevents multiple reveals

            // --- HELPER FUNCTIONS ---
            /**
             * Shuffles an array in place using the Fisher-Yates algorithm.
             * @param {Array} array The array to shuffle.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // --- CORE LOGIC ---
            /**
             * Initializes and sets up a new scratch card.
             */
            function setupCard() {
                revealInProgress = false;
                
                // Set the background image for the current card
                cardContainer.style.backgroundImage = `url('${imagesToShow[currentImageIndex]}')`;

                // Create and configure the canvas element
                canvas = document.createElement('canvas');
                canvas.id = 'scratch-canvas';
                cardContainer.innerHTML = ''; // Clear previous canvas if any
                cardContainer.appendChild(canvas);
                ctx = canvas.getContext('2d', { willReadFrequently: true });

                // Set canvas dimensions based on the container's current size
                const rect = cardContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                // Draw the scratchable overlay
                drawOverlay();
                
                // Add event listeners for interaction
                addEventListeners();
            }
            
            /**
             * Draws the metallic gradient overlay that the user scratches off.
             */
            function drawOverlay() {
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#c0c0c0'); // Silver
                gradient.addColorStop(0.5, '#e0e0e0'); // Lighter silver
                gradient.addColorStop(1, '#c0c0c0'); // Silver
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            /**
             * Attaches mouse and touch event listeners to the canvas.
             */
            function addEventListeners() {
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('touchstart', startDrawing, { passive: true });
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('touchmove', draw, { passive: true });
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('touchend', stopDrawing);
                canvas.addEventListener('mouseleave', stopDrawing);
            }
            
            /**
             * Gets the coordinates of the mouse or touch event on the canvas.
             * @param {Event} event The mouse or touch event.
             * @returns {Object} An object with x and y coordinates.
             */
            function getCoordinates(event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (event.touches && event.touches[0]) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            function startDrawing(e) {
                isDrawing = true;
                draw(e); // Draw a point on the initial click/touch
            }

            function stopDrawing() {
                isDrawing = false;
            }
            
            /**
             * The main drawing function that scratches off the overlay.
             * @param {Event} event The mouse or touch event.
             */
            function draw(event) {
                if (!isDrawing || revealInProgress) return;
                event.preventDefault();

                const { x, y } = getCoordinates(event);

                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2, false); // Scratch radius
                ctx.fill();
                
                // Check scratch percentage after drawing
                checkScratchPercentage();
            }
            
            /**
             * Calculates the percentage of the canvas that has been cleared.
             */
            function checkScratchPercentage() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                let transparentPixels = 0;

                // Iterate through pixel data (every 4th value is alpha)
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] === 0) {
                        transparentPixels++;
                    }
                }
                
                const totalPixels = data.length / 4;
                const percentage = (transparentPixels / totalPixels) * 100;

                // If threshold is met, trigger the auto-reveal
                if (percentage > 70) {
                    autoReveal();
                }
            }

            /**
             * Animates the rest of the overlay away and transitions to the next state.
             */
            function autoReveal() {
                if (revealInProgress) return;
                revealInProgress = true;
                isDrawing = false; // Stop any further drawing

                // Animate clearing the canvas
                let alpha = 1;
                const fadeOut = setInterval(() => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawOverlay(); // Redraw overlay
                    ctx.fillStyle = `rgba(0, 0, 0, ${1 - alpha})`;
                    ctx.globalCompositeOperation = 'destination-in';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    alpha -= 0.05;
                    if (alpha <= 0) {
                        clearInterval(fadeOut);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Wait a moment before showing the message
                        setTimeout(handleNextStep, 1000);
                    }
                }, 20);
            }

            /**
             * Determines whether to show the next card or the final message.
             */
            function handleNextStep() {
                // Check if we are on the last image (the "YOU" image)
                if (currentImageIndex >= imagesToShow.length - 1) {
                    // Final reveal
                    mainHeading.textContent = "It's been you all along...";
                    subHeading.textContent = "It's YOU! 🥰";
                    subHeading.classList.remove('opacity-0');
                    cardContainer.classList.remove('custom-cursor');
                    cardContainer.classList.add('cursor-default');

                } else {
                    // Show the "try again" message
                    subHeading.textContent = "Scratch again... that's not the one!";
                    subHeading.classList.remove('opacity-0');
                    
                    // After a delay, set up the next card
                    setTimeout(() => {
                        subHeading.classList.add('opacity-0');
                        currentImageIndex++;
                        setupCard();
                    }, 2000);
                }
            }
            
            /**
             * Main initialization function.
             */
            function init() {
                shuffleArray(actressImages);
                imagesToShow = [...actressImages, finalImage];
                setupCard();
                
                // Add a resize listener to rescale the canvas if the window size changes
                window.addEventListener('resize', () => {
                    // Use a timeout to avoid excessive recalcs during resize
                    clearTimeout(window.resizedFinished);
                    window.resizedFinished = setTimeout(setupCard, 250);
                });
            }

            // Start the application
            init();
        });
    </script>
</body>
</html>
